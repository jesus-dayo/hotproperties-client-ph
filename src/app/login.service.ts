import {Inject, Injectable} from '@angular/core';
import {HttpClient, HttpHeaders, HttpResponse} from '@angular/common/http';
import {MessageService} from './message.service';
import {Response} from '@angular/http';
import {Observable} from 'rxjs/Observable';
import {of} from 'rxjs/observable/of';
import {Credentials} from './credentials';
import * as moment from 'moment';
import {LOCAL_STORAGE, WebStorageService} from 'angular-webstorage-service';

const httpOptions = {
    headers: new HttpHeaders({'Content-Type': 'application/json'})
};

@Injectable()
export class LoginService {

    public data: any = [];

  private propertyUrl = '';

    authenticated: boolean;

    constructor(private http: HttpClient, private messageService: MessageService
        , @Inject(LOCAL_STORAGE) private localStorage: WebStorageService) {
    }

    authenticate(credentials: Credentials): Observable<HttpResponse<any>> {
        const url = `${this.propertyUrl}/login`;
        return this.http.post(url, credentials, {observe: 'response'});
    }

    logout() {
        this.localStorage.remove('id_token');
        //this.localStorage.remove("expires_at");
    }

    public isLoggedIn() {
        return this.localStorage.get('id_token');
    }

    isLoggedOut() {
        return !this.isLoggedIn();
    }

    getExpiration() {
        const expiration = this.localStorage.get('expires_at');
        const expiresAt = JSON.parse(expiration);
        return moment(expiresAt);
    }

    handleSuccess(response: Response) { // the return here is any, as you dont know how do the POJO(s) generated by response.json() look like
        let body;
        if (response) {
            body = response;
        }

        return body || {};
    }

    /**
     * Handle Http operation that failed.
     * Let the app continue.
     * @param operation - name of the operation that failed
     * @param result - optional value to return as the observable result
     */
    private handleError<T>(operation = 'operation', result?: T) {
        return (error: any): Observable<T> => {

            // TODO: send the error to remote logging infrastructure
            console.error(error); // log to console instead

            // TODO: better job of transforming error for user consumption
            this.log(`${operation} failed: ${error.message}`);

            // Let the app keep running by returning an empty result.
            return of(result as T);
        };
    }

    /** Log a HeroService message with the MessageService */
    private log(message: string) {
        this.messageService.add('HeroService: ' + message);
    }

}
